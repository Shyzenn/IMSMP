generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id       String @id @default(uuid())
  username String @unique
  role     Role
  email    String @unique
  password String
  
  firstName String @default("N/A")
  lastName  String @default("N/A")
  middleName String? 

  profileImage String?

  otp                String?
  otpExpiresAt       DateTime?
  createdAt          DateTime   @default(now())

  status             UserStatus @default(ACTIVE)
  bannedReason       String?
  bannedAt           DateTime?

  mustChangePassword Boolean    @default(true)

  OrderRequest      OrderRequest[]      @relation("RequestedBy")
  WalkInTransaction WalkInTransaction[]

  ReceivedOrders  OrderRequest[] @relation("ReceivedBy")
  ProcessedOrders OrderRequest[] @relation("ProcessedBy")
  RefundedByOrderRequest      OrderRequest[] @relation("RefundedBy")
  RefundedByWalkIn            WalkInTransaction[] @relation("RefundedBy")

  ProcessedWalkinOrders WalkInTransaction[] @relation("ProcessedBy")

  Product  Product[]
  AuditLog AuditLog[]
  lastSeen DateTime   @default(now()) @updatedAt
  isOnline Boolean    @default(false)

  SentNotification     Notification[] @relation("SentNotification")
  ReceivedNotification Notification[] @relation("ReceivedNotification")

  ArchivedProducts      Product[]       @relation("ArchivedProducts")
  ArchivedBatches       ProductBatch[]  @relation("ArchivedBatches")
  ArchivedOrderRequests OrderRequest[]  @relation("ArchivedOrderRequests")
}

enum Role {
  SuperAdmin
  MedTech
  Pharmacist_Staff
  Nurse
  Manager
  Cashier
}

enum UserStatus {
  ACTIVE
  DISABLE
}

model AuditLog {
  id     Int    @id @default(autoincrement())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  action      String // e.g. CREATE_ORDER, UPDATE_USER
  entityType  String // e.g. User, Order, Product
  entityId    Int? // The affected record (nullable in case it's a general action)
  description String? // Human-readable summary

  createdAt DateTime @default(now())
}

model Product {
  id           Int       @id @default(autoincrement())
  product_name String    @unique
  price        Decimal   @default(0.00)
  status       String    @default("ACTIVE") // ACTIVE | ARCHIVED
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  archivedById String?
  archivedByUser User? @relation("ArchivedProducts", fields: [archivedById], references: [id])
  archiveAt    DateTime?
  archiveReason String?

  // Relationships
  batches      ProductBatch[]
  orderItems   OrderItem[]
  WalkInItem   WalkInItem[]
  Notification Notification[]

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  categoryId Int?
  category   ProductCategory? @relation(fields: [categoryId], references: [id])

 
}

model ProductBatch {
  id        Int       @id @default(autoincrement())
  productId Int
  product   Product   @relation(fields: [productId], references: [id])

  archiveAt DateTime?
  archiveReason String?
  archivedById String?
  archivedByUser User? @relation("ArchivedBatches", fields: [archivedById], references: [id])

  batchNumber String
  quantity    Int      @default(0)
  releaseDate DateTime
  expiryDate  DateTime
  type        String   @default("ACTIVE") // ACTIVE | EXPIRING | EXPIRED | CONSUMED | ARCHIVED

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductCategory {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[]
}

model OrderRequest {
  id           Int      @id @default(autoincrement())
  room_number  String?
  patient_name String?
  status       Status  
  remarks      Remarks  @default(preparing)
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  refundedAt    DateTime?
  refundedBy    User?   @relation("RefundedBy", fields: [refundedById], references: [id])
  refundedById  String?
  refundReason  String?

  type OrderType @default(REGULAR)

  // Archive tracking
  archivedById    String?
  archivedByUser  User? @relation("ArchivedOrderRequests", fields: [archivedById], references: [id])
  isArchived      Boolean @default(false)
  archiveReason   String?

  user   User   @relation("RequestedBy", fields: [userId], references: [id])
  userId String

  receivedBy   User?   @relation("ReceivedBy", fields: [receivedById], references: [id])
  receivedById String?

  processedBy   User?   @relation("ProcessedBy", fields: [processedById], references: [id])
  processedById String?

  receivedAt  DateTime?
  processedAt DateTime?

  items        OrderItem[]
  Notification Notification[]
}

enum Remarks {
  preparing
  prepared
  dispensed
}

enum OrderType {
  REGULAR
  EMERGENCY
}

model OrderItem {
  id        Int          @id @default(autoincrement())
  quantity  Int          @default(1)
  refundedQuantity Int   @default(0)
  order     OrderRequest @relation(fields: [orderId], references: [id])
  orderId   Int
  product   Product      @relation(fields: [productId], references: [id])
  productId Int
}

model WalkInTransaction {
  id            Int            @id @default(autoincrement())
  customer_name String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  status        Status

  processedBy   User?   @relation("ProcessedBy", fields: [processedById], references: [id])
  processedById String?

  refundedAt    DateTime?
  refundedBy    User?   @relation("RefundedBy", fields: [refundedById], references: [id])
  refundedById  String?
  refundReason  String?

  items         WalkInItem[]
  totalAmount   Decimal        @default(0.00)
  userId        String // pharmacist who encoded the walk-in
  user          User           @relation(fields: [userId], references: [id])
  Notification  Notification[]
}

model WalkInItem {
  id            Int               @id @default(autoincrement())
  quantity      Int
  refundedQuantity Int            @default(0)
  price         Decimal
  total         Decimal // quantity * price
  product       Product           @relation(fields: [productId], references: [id])
  productId     Int
  transaction   WalkInTransaction @relation(fields: [transactionId], references: [id])
  transactionId Int
}

enum Status {
  pending
  for_payment
  paid
  canceled
  refunded
}

enum NotificationType {
  ORDER_REQUEST
  ADD_PRODUCT
  ORDER_RECEIVED
  PAYMENT_PROCESSED
  EMERGENCY_ORDER
  REMARKS
  WALK_IN
}

model Notification {
  id        Int      @id @default(autoincrement())
  title     String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  senderId    String
  recipientId String
  sender      User   @relation("SentNotification", fields: [senderId], references: [id])
  recipient   User   @relation("ReceivedNotification", fields: [recipientId], references: [id])

  orderId Int?
  order   OrderRequest? @relation(fields: [orderId], references: [id])

  walkInOrderId Int?
  walkInOrder   WalkInTransaction? @relation(fields: [walkInOrderId], references: [id])

  productId Int?
  product   Product? @relation(fields: [productId], references: [id])

  type NotificationType?

  patientName String?
  roomNumber  String?
  submittedBy String?
  role        String?
}
