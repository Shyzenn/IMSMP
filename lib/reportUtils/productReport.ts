import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";

export const logoPath = "/macoleens_logo.png";

export interface ProductExportData {
  id: number;
  product_name: string;
  category: string;
  batches: number;
  totalQuantity: number;
  price: number;
}

export interface ExportMeta {
  type: string;
  category?: string;
  query?: string; 
  generatedBy: string
  stockFilter?: string;
  lowStockThreshold: number;
}

export type LastAutoTableShape = { lastAutoTable?: { finalY?: number } };

export const generateProductPDF = (
  products: ProductExportData[],
  meta: ExportMeta,
  generatedBy?: string
) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.width;
  const marginLeft = 10;

  // Logo
  const logoWidth = 45;
  const logoHeight = 10;
  doc.addImage(logoPath, "PNG", (pageWidth / 2) - (logoWidth / 2), 8, logoWidth, logoHeight);

  // --- Title ---
  let textY = 30;
  doc.setFontSize(18);
  doc.setFont("helvetica", "bold");
  doc.text("Product Inventory Report", pageWidth / 2, textY, { align: "center" });

  // Add spacing before report details
  textY += 12;

  // --- Report Details ---
  const labelX = marginLeft;
  const smallGap = 2;

  doc.setFontSize(10);

  const printDetail = (label: string, value: string) => {
    doc.setFont("helvetica", "bold");
    doc.text(label, labelX, textY);
    const labelWidth = doc.getTextWidth(label);
    doc.setFont("helvetica", "normal");
    doc.text(value, labelX + labelWidth + smallGap, textY);
    textY += 6;
  };

  // Report Type
  const reportType =
    meta.type === "lowStock" ? "Low Stock Products" : "All Products";
  printDetail("Report Type:", reportType);

  // Generated At (use meta.generatedAt)
  printDetail("Generated At:", new Date().toLocaleString());

  // Generated By (optional)
  if (generatedBy) {
    printDetail("Generated By:", generatedBy);
  }

  // Add extra space before filters
  let startY = textY;

  // --- Applied Filters Section ---
  if (
    meta.category !== "All" ||
    meta.query ||
    (meta.stockFilter && meta.stockFilter !== "all")
  ) {
    doc.setFontSize(9);
    doc.setFont("helvetica", "bold");
    doc.text("Applied Filters:", marginLeft, startY);
    doc.setFont("helvetica", "normal");
    startY += 5;

  if (meta.category && meta.category !== "All") {
    doc.setFont("helvetica", "bold");
    doc.text("  • Category:", marginLeft, startY);
    const labelWidth = doc.getTextWidth("  • Category:");
    doc.setFont("helvetica", "normal");
    doc.text(` ${meta.category}`, marginLeft + labelWidth, startY);
    startY += 5;
  }

  if (meta.query) {
    doc.setFont("helvetica", "bold");
    doc.text("  • Search:", marginLeft, startY);
    const labelWidth = doc.getTextWidth("  • Search:");
    doc.setFont("helvetica", "normal");
    doc.text(` "${meta.query}"`, marginLeft + labelWidth, startY);
    startY += 5;
  }

  if (meta.stockFilter && meta.stockFilter !== "all") {
      const filterLabels: Record<string, string> = {
        inStock: "In Stock",
        outOfStock: "Out of Stock",
        lowStock: "Low Stock",
      };
      doc.text(
        `  • Stock Filter: ${filterLabels[meta.stockFilter] || meta.stockFilter}`,
        marginLeft,
        startY
      );
      startY += 5;
    }
    startY += 5;
  }

  // --- Table Data ---
  const tableData = products.map((product) => {
    const status =
      product.totalQuantity === 0
        ? "Out of Stock"
        : product.totalQuantity <= meta.lowStockThreshold
        ? "Low Stock"
        : "In Stock";

    return [
      product.product_name,
      product.category,
      product.batches.toString(),
      product.totalQuantity.toString(),
      `PHP ${product.price.toFixed(2)}`,
      status,
    ];
  });

  // --- Table ---
  autoTable(doc, {
    head: [["Product Name", "Category", "Batches", "Stock", "Price", "Status"]],
    body: tableData,
    startY,
    margin: { left: marginLeft, right: marginLeft },
    theme: "grid",
    headStyles: {
      fillColor: [59, 130, 246],
      textColor: 255,
      fontStyle: "bold",
      fontSize: 9,
    },
    bodyStyles: { fontSize: 8 },
    columnStyles: {
      0: { cellWidth: 60 },
      1: { cellWidth: 35 },
      2: { cellWidth: 20 },
      3: { cellWidth: 20 },
      4: { cellWidth: 25 },
      5: { cellWidth: 30 },
    },
    didParseCell: (data) => {
      if (data.column.index === 5 && data.section === "body") {
        const status = data.cell.text[0];
        if (status === "Out of Stock") data.cell.styles.textColor = [220, 38, 38];
        else if (status === "Low Stock") data.cell.styles.textColor = [245, 158, 11];
        else if (status === "In Stock") data.cell.styles.textColor = [22, 163, 74];
      }
    },
    didDrawPage: () => {
      const pageCount = doc.getNumberOfPages();
      const pageNumber = doc.getCurrentPageInfo().pageNumber;
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(
        `Page ${pageNumber} of ${pageCount}`,
        pageWidth / 2,
        doc.internal.pageSize.height - 10,
        { align: "center" }
      );
    },
  });

  // --- Summary ---
  const lastAutoTable = (doc as LastAutoTableShape).lastAutoTable;
  const finalY = lastAutoTable?.finalY ?? startY + 10;

  const totalStock = products.reduce((sum, p) => sum + p.totalQuantity, 0);
  const totalValue = products.reduce(
    (sum, p) => sum + p.totalQuantity * p.price,
    0
  );

  doc.setFontSize(9);
  doc.setFont("helvetica", "bold");
  doc.text(`Total Products: ${products.length}`, 14, finalY + 10);
  doc.text(`Total Stock: ${totalStock} units`, 80, finalY + 10);
  doc.text(
    `Total Value: PHP ${totalValue.toLocaleString("en-US", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })}`,
    150,
    finalY + 10
  );

  // --- Save PDF ---
  doc.save(`products-${meta.type}-${Date.now()}.pdf`);
};