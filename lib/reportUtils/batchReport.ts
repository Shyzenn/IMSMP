import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import { LastAutoTableShape, logoPath } from "./productReport";

export const generateBatchPDF = (
  batches: {
    batchNumber: string;
    productName: string;
    category: string;
    quantity: number;
    expiryDate: string;
    status: string;
  }[],
  meta: { type: string; generatedAt: string },
  generatedBy?: string
) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.width;
  const marginLeft = 10;

  const logoWidth = 45;
  const logoHeight = 10;
  doc.addImage(logoPath, "PNG", (pageWidth / 2) - (logoWidth / 2), 8, logoWidth, logoHeight);

   // --- Header ---
  let textY = 30;

  doc.setFontSize(14);
  doc.setFont("helvetica", "bold");
  doc.text("Product Batch Report", pageWidth / 2, textY, { align: "center" });

  textY += 14;
  doc.setFontSize(10);

  // Match tableâ€™s left margin (marginLeft = 10)
  const labelX = marginLeft;
  const smallGap = 2;

  // Report Type
  const printDetail = (label: string, value: string) => {
    doc.setFont("helvetica", "bold");
    doc.text(label, labelX, textY);
    const labelWidth = doc.getTextWidth(label);
    doc.setFont("helvetica", "normal");
    doc.text(value, labelX + labelWidth + smallGap, textY);
    textY += 6;
  };

  // Report Type
  const reportType =
    meta.type === "expiring"
      ? "Expiring Batches (Next 31 Days)"
      : meta.type === "expired"
      ? "Expired Batches"
      : meta.type === "consumed"
      ? "Consumed Batches"
      : "All Batches";

  printDetail("Report Type:", reportType);

  // Generated
  printDetail("Generated:", new Date(meta.generatedAt).toLocaleString());

  // Generated By (optional)
  if (generatedBy) {
    printDetail("Generated By:", generatedBy);
  }

  // --- Start Table ---
  const startY = textY;

  autoTable(doc, {
    head: [["Batch No.", "Product Name", "Category", "Quantity", "Expiry Date", "Status"]],
    body: batches.map((b) => [
      b.batchNumber,
      b.productName,
      b.category,
      b.quantity.toString(),
      b.expiryDate,
      b.status,
    ]),
    startY,
    margin: { left: marginLeft, right: marginLeft },
    theme: "grid",
    headStyles: {
      fillColor: [59, 130, 246],
      textColor: 255,
      fontStyle: "bold",
      fontSize: 9,
    },
    bodyStyles: {
      fontSize: 8,
    },
    didParseCell: (data) => {
      if (data.column.index === 5 && data.section === "body") {
        const status = data.cell.text[0];
        if (status === "Expired") {
          data.cell.styles.textColor = [220, 38, 38]; // red
        } else if (status === "Expiring Soon") {
          data.cell.styles.textColor = [245, 158, 11]; // orange
        } else if (status === "Consumed") {
          data.cell.styles.textColor = [107, 114, 128]; // gray
        } else {
          data.cell.styles.textColor = [22, 163, 74]; // green
        }
      }
    },
    didDrawPage: () => {
      const pageCount = doc.getNumberOfPages();
      const pageNumber = doc.getCurrentPageInfo().pageNumber;
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(
        `Page ${pageNumber} of ${pageCount}`,
        pageWidth / 2,
        doc.internal.pageSize.height - 10,
        { align: "center" }
      );
    },
  });

  const totalQty = batches.reduce((sum, b) => sum + b.quantity, 0);

  const lastAutoTable = (doc as unknown as LastAutoTableShape).lastAutoTable;
  const finalY = lastAutoTable?.finalY ?? startY + 10;
  doc.setFont("helvetica", "bold");
  doc.text(`Total Batches: ${batches.length}`, 14, finalY + 10);
  doc.text(`Total Quantity: ${totalQty}`, 80, finalY + 10);

  doc.save(`batches-${meta.type}-${Date.now()}.pdf`);
};
