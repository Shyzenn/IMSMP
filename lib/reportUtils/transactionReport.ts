import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import { format } from "date-fns";
import { capitalLetter, statusLabels } from "../utils";
import { LastAutoTableShape, logoPath } from "./productReport";

interface TransactionItem {
  productName: string;
  quantity: number;
  price: number;
}

interface Transaction {
  id: number;
  customer: string;
  patient_name?: string;
  roomNumber?: number;
  type: string;
  createdAt: Date;
  source: "Walk In" | "Request Order";
  subtotal: number;
  discount: number;
  isVatExempt: boolean;
  total: number;
  requestedBy?: string;
  receivedBy?: string;
  processedBy?: string;
  handledBy?: string;
  status: string;
  itemDetails: TransactionItem[];
}

interface ReportMeta {
  dateRange: {
    from: string | null;
    to: string | null;
  };
  searchQuery: string | null;
  statusFilters: string[] | null;
  sourceFilters: string[] | null;
  totalTransactions: number;
  totalAmount: number;
  totalDiscount: number;
  totalSubtotal: number;
  generatedAt: string;
}

export const generateTransactionPDF = (
  transactions: Transaction[],
  meta: ReportMeta,
  generatedBy: string
) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();

  // --- Header ---
  const logoWidth = 50;
  const logoHeight = 12;
  doc.addImage(
    logoPath,
    "PNG",
    (pageWidth - logoWidth) / 2,
    8,
    logoWidth,
    logoHeight
  );

  doc.setFontSize(14);
  doc.text("Transaction Report", pageWidth / 2, 30, { align: "center" });

  // Report Info
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  let yPos = 45;

  function addLabelValue(label: string, value: string) {
    doc.setFont("helvetica", "bold");
    doc.text(label, 14, yPos);
    const labelWidth = doc.getTextWidth(label);
    doc.setFont("helvetica", "normal");
    doc.text(value, 14 + labelWidth + 2, yPos);
    yPos += 5;
  }

  if (meta.dateRange.from || meta.dateRange.to) {
    const fromDate = meta.dateRange.from
      ? format(new Date(meta.dateRange.from), "MMM dd, yyyy")
      : "Start";
    const toDate = meta.dateRange.to
      ? format(new Date(meta.dateRange.to), "MMM dd, yyyy")
      : "End";
    addLabelValue("Period:", `${fromDate} - ${toDate}`);
  }

  if (meta.searchQuery) {
    addLabelValue("Search:", meta.searchQuery);
  }

  if (meta.statusFilters && meta.statusFilters.length > 0) {
    const statusLabelsText = meta.statusFilters
      .map((s) => statusLabels[s] || capitalLetter(s))
      .join(", ");
    addLabelValue("Status Filters:", statusLabelsText);
  }

  if (meta.sourceFilters && meta.sourceFilters.length > 0) {
    const sourceLabelsText = meta.sourceFilters
      .map((s) => (s === "order_request" ? "Order Request" : "Walk In"))
      .join(", ");
    addLabelValue("Source Filters:", sourceLabelsText);
  }

  addLabelValue("Total Transactions:", `${meta.totalTransactions}`);
  addLabelValue("Generated By:", generatedBy);
  addLabelValue(
    "Generated At:",
    format(new Date(meta.generatedAt), "MMM dd, yyyy hh:mm a")
  );

  yPos += 5;

  // --- Table ---
  const tableData = transactions.map((tx) => {
    const itemCount = tx.itemDetails.reduce(
      (sum, item) => sum + item.quantity,
      0
    );

    return [
      format(new Date(tx.createdAt), "MMM dd, yyyy hh:mm a"),
      tx.source === "Walk In" ? tx.customer : tx.patient_name || tx.customer,
      tx.source === "Request Order" && tx.roomNumber
        ? `Room ${tx.roomNumber}`
        : "-",
      capitalLetter(tx.type),
      tx.source,
      statusLabels[tx.status] || tx.status,
      String(itemCount),
      tx.subtotal.toFixed(2),
      tx.discount > 0 ? tx.discount.toFixed(2) : "-",
      tx.isVatExempt ? "Yes" : "-",
      tx.total.toFixed(2),
    ];
  });

  autoTable(doc, {
    startY: yPos,
    head: [
      [
        "Date",
        "Customer/Patient",
        "Room",
        "Type",
        "Source",
        "Status",
        "Items",
        "Subtotal",
        "Total (PHP)",
      ],
    ],
    body: tableData,
    theme: "grid",
    headStyles: {
      fillColor: [66, 139, 202],
      textColor: 255,
      fontStyle: "bold",
      fontSize: 8,
    },
    bodyStyles: { fontSize: 7 },
    columnStyles: {
      0: { cellWidth: 30 },
      1: { cellWidth: 25 },
      2: { cellWidth: 15 },
      3: { cellWidth: 18 },
      4: { cellWidth: 22 },
      5: { cellWidth: 20 },
      6: { cellWidth: 12, halign: "center" },
      7: { cellWidth: 18, halign: "right" },
      10: { cellWidth: 20, halign: "right" },
    },
    margin: { left: 14, right: 14 },
  });

  // --- Summary below table ---
  const finalY =
    ((doc as LastAutoTableShape).lastAutoTable?.finalY || yPos) + 10;

  doc.setFont("helvetica", "bold");
  doc.setFontSize(10);
  doc.text("Summary", 14, finalY);

  let summaryY = finalY + 6;
  doc.setFontSize(9);
  doc.setFont("helvetica", "normal");

  const summaryData = [
    ["Gross Amount:", `PHP ${meta.totalSubtotal.toFixed(2)}`],
    ["Total Discounts:", `PHP ${meta.totalDiscount.toFixed(2)}`],
  ];

  summaryData.forEach(([label, value]) => {
    doc.text(label, 14, summaryY);
    doc.text(value, 70, summaryY);
    summaryY += 5;
  });

  // Net Total
  summaryY += 2;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(11);
  doc.text("Net Total:", 14, summaryY);
  doc.text(`PHP ${meta.totalAmount.toFixed(2)}`, 70, summaryY);

  // --- Save ---
  const fileName = `Transaction_Report_${format(
    new Date(),
    "yyyyMMdd_HHmmss"
  )}.pdf`;
  doc.save(fileName);
};
